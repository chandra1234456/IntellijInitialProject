<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Android ViewModel - Architecture Component</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 30px;
            background: #f4f6f8;
            color: #333;
        }
        h1, h2, h3 {
            color: #1f3c88;
        }
        section {
            background: #ffffff;
            padding: 20px;
            margin-bottom: 25px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.06);
        }
        ul {
            line-height: 1.8;
        }
        .code {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
        }
        .diagram {
            text-align: center;
            margin-top: 20px;
        }
        svg text {
            font-size: 14px;
        }
        .box {
            fill: #e3f2fd;
            stroke: #1565c0;
            stroke-width: 2;
        }
        .arrow {
            stroke: #333;
            stroke-width: 2;
            marker-end: url(#arrowhead);
        }
    </style>
</head>
<body>

<h1>Android ViewModel</h1>

<section>
    <h2>1. What is ViewModel?</h2>
    <p>
        <strong>ViewModel</strong> is a Jetpack Architecture Component designed to
        store and manage UI-related data in a lifecycle-conscious way.
    </p>
    <ul>
        <li>Survives configuration changes (rotation)</li>
        <li>Separates UI logic from business logic</li>
        <li>Works perfectly with LiveData & StateFlow</li>
    </ul>
</section>

<section>
    <h2>2. Why ViewModel is Needed?</h2>
    <ul>
        <li>Avoid data loss on screen rotation</li>
        <li>Cleaner architecture (MVVM)</li>
        <li>Reduce memory leaks</li>
        <li>Better testability</li>
    </ul>
</section>

<section>
    <h2>3. How ViewModel Works Internally</h2>
    <ul>
        <li>ViewModel is created by <strong>ViewModelProvider</strong></li>
        <li>Attached to Activity / Fragment lifecycle</li>
        <li>Not destroyed on configuration changes</li>
        <li>Destroyed only when lifecycle owner is finished</li>
    </ul>

    <p><strong>Important:</strong> ViewModel never holds reference to View.</p>
</section>

<section>
    <h2>4. ViewModel Lifecycle Flow (Graphical)</h2>

    <div class="diagram">
        <svg width="700" height="420">
            <defs>
                <marker id="arrowhead" markerWidth="10" markerHeight="7"
                        refX="10" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" />
                </marker>
            </defs>

            <rect class="box" x="260" y="20" width="180" height="50"/>
            <text x="295" y="50">Activity / Fragment</text>

            <rect class="box" x="260" y="120" width="180" height="60"/>
            <text x="295" y="155">ViewModel</text>

            <rect class="box" x="70" y="240" width="200" height="60"/>
            <text x="110" y="275">Repository</text>

            <rect class="box" x="430" y="240" width="200" height="60"/>
            <text x="465" y="275">Data Source</text>

            <line class="arrow" x1="350" y1="70" x2="350" y2="120"/>
            <line class="arrow" x1="260" y1="180" x2="170" y2="240"/>
            <line class="arrow" x1="440" y1="180" x2="530" y2="240"/>
        </svg>
    </div>
</section>

<section>
    <h2>5. ViewModel Usage Example</h2>

    <h3>ViewModel Class</h3>
    <div class="code">
        class UserViewModel : ViewModel() {

        private val _users = MutableLiveData&lt;List&lt;User&gt;&gt;()
        val users: LiveData&lt;List&lt;User&gt;&gt; = _users

        fun loadUsers() {
        _users.value = listOf(User("John"), User("Emma"))
        }
        }
    </div>

    <h3>Activity</h3>
    <div class="code">
        class MainActivity : AppCompatActivity() {

        private val viewModel: UserViewModel by viewModels()

        override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        viewModel.users.observe(this) {
        // Update UI
        }
        }
        }
    </div>
</section>

<section>
    <h2>6. ViewModel with Hilt (Injection)</h2>

    <div class="code">
        @HiltViewModel
        class UserViewModel @Inject constructor(
        private val repository: UserRepository
        ) : ViewModel()
    </div>

    <ul>
        <li>Hilt creates ViewModel automatically</li>
        <li>Dependencies injected via constructor</li>
        <li>No manual factory required</li>
    </ul>
</section>

<section>
    <h2>7. Where ViewModel is Used</h2>
    <ul>
        <li>UI State Management</li>
        <li>Network call handling</li>
        <li>Business logic holder</li>
        <li>MVVM Architecture</li>
        <li>Jetpack Compose State</li>
    </ul>
</section>

<section>
    <h2>8. Pros of ViewModel</h2>
    <ul>
        <li>Survives configuration changes</li>
        <li>Lifecycle-aware</li>
        <li>Cleaner code structure</li>
        <li>Easy to test</li>
    </ul>
</section>

<section>
    <h2>9. Cons of ViewModel</h2>
    <ul>
        <li>Cannot reference View or Context directly</li>
        <li>Overkill for small apps</li>
        <li>Requires understanding of lifecycle</li>
    </ul>
</section>

<section>
    <h2>10. ViewModel vs Activity</h2>
    <ul>
        <li>Activity handles UI</li>
        <li>ViewModel handles data & logic</li>
        <li>Activity can be destroyed, ViewModel survives</li>
    </ul>
</section>

<section>
    <h2>11. Summary</h2>
    <p>
        ViewModel is a core component of modern Android development.
        It separates concerns, survives configuration changes, and
        works seamlessly with Hilt and MVVM architecture.
    </p>
</section>

</body>
</html>
