<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Kotlin Coroutines Interview Questions</title>
</head>
<body>

<h1>Kotlin Coroutines ‚Äì Interview Questions</h1>

<h2>Basics</h2>
<ul>
    <li>What are coroutines in Kotlin?</li>
    <li>How are coroutines different from threads?</li>
    <li>What problem do coroutines solve?</li>
    <li>What is a suspending function?</li>
    <li>Is <code>suspend fun</code> a coroutine? Explain.</li>
</ul>

<h2>Coroutine Builders</h2>
<ul>
    <li>What is <code>launch</code>?</li>
    <li>What is <code>async</code>?</li>
    <li>Difference between <code>launch</code> and <code>async</code>?</li>
    <li>What is <code>runBlocking</code> and when should it be used?</li>
</ul>

<h2>Coroutine Scope & Context</h2>
<ul>
    <li>What is <code>CoroutineScope</code>?</li>
    <li>What is <code>CoroutineContext</code>?</li>
    <li>What is a Dispatcher?</li>
    <li>Difference between <code>Dispatchers.Main</code>, <code>IO</code>, and <code>Default</code>?</li>
    <li>What happens if no dispatcher is specified?</li>
</ul>

<h2>Suspension & Cancellation</h2>
<ul>
    <li>What does suspension mean in coroutines?</li>
    <li>How does <code>delay()</code> work internally?</li>
    <li>How do you cancel a coroutine?</li>
    <li>What is cooperative cancellation?</li>
    <li>What is <code>isActive</code>?</li>
</ul>

<h2>Exception Handling</h2>
<ul>
    <li>How are exceptions handled in coroutines?</li>
    <li>Difference between exception handling in <code>launch</code> and <code>async</code>?</li>
    <li>What is <code>CoroutineExceptionHandler</code>?</li>
    <li>What happens when one coroutine fails?</li>
</ul>

<h2>Structured Concurrency</h2>
<ul>
    <li>What is structured concurrency?</li>
    <li>Why is structured concurrency important?</li>
    <li>What is a parent-child coroutine relationship?</li>
    <li>What is <code>supervisorScope</code>?</li>
</ul>

<h2>Advanced</h2>
<ul>
    <li>What are cold vs hot streams?</li>
    <li>Difference between <code>Flow</code> and <code>Sequence</code>?</li>
    <li>What is <code>withContext</code>?</li>
    <li>How do coroutines improve performance?</li>
    <li>How do coroutines work internally?</li>
</ul>

<h2>Android-Specific</h2>
<ul>
    <li>What is <code>lifecycleScope</code>?</li>
    <li>What is <code>viewModelScope</code>?</li>
    <li>Why should coroutines be lifecycle-aware?</li>
    <li>How do you avoid memory leaks with coroutines?</li>
</ul>

<h3>üî• Coroutine Scopes ‚Äì Interview Summary</h3>

<table>
    <thead>
    <tr>
        <th>Scope</th>
        <th>Where Used</th>
        <th>Cancelled When</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>viewModelScope</td>
        <td>ViewModel</td>
        <td>onCleared()</td>
    </tr>
    <tr>
        <td>lifecycleScope</td>
        <td>Activity / Fragment</td>
        <td>onDestroy()</td>
    </tr>
    <tr>
        <td>repeatOnLifecycle</td>
        <td>UI + Flow</td>
        <td>STOPPED</td>
    </tr>
    <tr>
        <td>CoroutineScope()</td>
        <td>Custom</td>
        <td>Manual</td>
    </tr>
    <tr>
        <td>runBlocking</td>
        <td>main / tests</td>
        <td>Blocking</td>
    </tr>
    <tr>
        <td>coroutineScope</td>
        <td>suspend fun</td>
        <td>Children finish</td>
    </tr>
    <tr>
        <td>supervisorScope</td>
        <td>Parallel tasks</td>
        <td>Parent</td>
    </tr>
    <tr>
        <td>MainScope()</td>
        <td>UI classes</td>
        <td>Manual</td>
    </tr>
    <tr>
        <td class="danger">GlobalScope ‚ùå</td>
        <td>‚Äî</td>
        <td>Never</td>
    </tr>
    </tbody>
</table>
<td>‚Äî  ---------------------------------------------------------------------------------                                                 -</td>

<div class="box">
    <strong>withContext</strong> switches dispatcher without launching a new coroutine,
    suspends the current coroutine, and returns the result once completed.
</div>

<h3>‚ùì Common Interview Follow-ups</h3>

<div class="qa">
    <p><strong>Q:</strong> Does <code>withContext</code> block the thread?</p>
    <p>‚úî No, it suspends the coroutine.</p>

    <p><strong>Q:</strong> When NOT to use <code>withContext</code>?</p>
    <p>‚úî When you need parallel execution ‚Üí use <code>async</code>.</p>

    <p><strong>Q:</strong> Can we use <code>withContext(Dispatchers.Main)</code>?</p>
    <p>‚úî Yes, to return to the UI thread.</p>
</div>

<h3>üéØ Quick Rule to Remember</h3>

<table>
    <thead>
    <tr>
        <th>Task</th>
        <th>Use</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>Thread switching</td>
        <td><code>withContext</code></td>
    </tr>
    <tr>
        <td>Parallel work</td>
        <td><code>async</code></td>
    </tr>
    <tr>
        <td>Fire &amp; forget</td>
        <td><code>launch</code></td>
    </tr>
    </tbody>
</table>

<div class="qa">
    <strong>1Ô∏è‚É£ What is a Coroutine Dispatcher?</strong><br>
    A dispatcher decides which thread or thread pool a coroutine runs on.
</div>

<div class="qa">
    <strong>2Ô∏è‚É£ How many main dispatchers are there?</strong><br>
    Four commonly used dispatchers:
    <ul>
        <li>Dispatchers.Main</li>
        <li>Dispatchers.IO</li>
        <li>Dispatchers.Default</li>
        <li>Dispatchers.Unconfined (rare)</li>
    </ul>
</div>

<div class="qa">
    <strong>3Ô∏è‚É£ Difference between Dispatchers.IO and Dispatchers.Default?</strong>
    <table>
        <thead>
        <tr>
            <th>IO</th>
            <th>Default</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>Blocking work</td>
            <td>CPU-intensive work</td>
        </tr>
        <tr>
            <td>Network, DB</td>
            <td>Calculations</td>
        </tr>
        <tr>
            <td>Large thread pool</td>
            <td>Limited threads</td>
        </tr>
        </tbody>
    </table>
</div>

<div class="qa">
    <strong>4Ô∏è‚É£ What happens if you run a network call on Dispatchers.Main?</strong><br>
    UI freezes ‚Üí ANR (Application Not Responding).
</div>

<div class="qa">
    <strong>5Ô∏è‚É£ When should you use Dispatchers.Default?</strong><br>
    For CPU-heavy tasks like:
    <ul>
        <li>Sorting</li>
        <li>Parsing JSON</li>
        <li>Encryption</li>
        <li>Calculations</li>
    </ul>
</div>

<div class="qa">
    <strong>6Ô∏è‚É£ What is Dispatchers.Unconfined?</strong><br>
    It starts in the current thread and resumes in any thread after suspension.<br>
    üö´ Avoid in production.
</div>

<div class="qa">
    <strong>7Ô∏è‚É£ Can we change dispatcher inside a coroutine?</strong><br>
    Yes, using <code>withContext</code>.
</div>

<div class="qa">
    <strong>8Ô∏è‚É£ Does withContext create a new coroutine?</strong><br>
    No. It suspends the current coroutine and switches the thread.
</div>

<div class="qa">
    <strong>9Ô∏è‚É£ What dispatcher does viewModelScope.launch {} use by default?</strong><br>
    Dispatchers.Main
</div>

<div class="qa">
    <strong>üîü What happens if you don‚Äôt specify a dispatcher?</strong><br>
    The coroutine inherits the parent‚Äôs dispatcher.
</div>

<h2>üî• BONUS (Very Common)</h2>

<div class="qa">
    <strong>Why is Dispatchers.IO not unlimited?</strong><br>
    To avoid resource exhaustion; it expands up to a safe limit and reuses threads.
</div>

<h2>üéØ One-Page Memory Trick</h2>

<div class="memory">
    <strong>Main</strong> ‚Üí UI<br>
    <strong>IO</strong> ‚Üí Network / DB<br>
    <strong>Default</strong> ‚Üí CPU<br>
    <strong>Unconfined</strong> ‚Üí Don‚Äôt use
</div>

<h2>üß† Rapid-Fire Follow-ups (Practice)</h2>

<div class="rapid">
    Can IO replace Default? ‚ùå<br>
    Is Main dispatcher blocking? ‚ùå<br>
    Does delay block thread? ‚ùå<br>
    Does Thread.sleep block? ‚úÖ
</div>
<h2>üî• Tricky Coroutine Interview Scenarios (Senior Level)</h2>

<p>Read the scenario ‚Üí think ‚Üí then see the answer.</p>

<div class="scenario">
    <strong>1Ô∏è‚É£ UI Freeze Scenario</strong><br><br>
    <strong>Scenario:</strong> API call inside <code>viewModelScope.launch {}</code> without dispatcher ‚Üí UI freezes.<br><br>
    <strong>Why?</strong><br>
    viewModelScope uses <code>Dispatchers.Main</code> by default.
    Network call runs on Main ‚Üí ANR.
    <div class="fix">
        ‚úî Fix: <code>withContext(Dispatchers.IO) { apiCall() }</code>
    </div>
</div>

<div class="scenario">
    <strong>2Ô∏è‚É£ Parallel vs Sequential Confusion</strong><br><br>
    <strong>Scenario:</strong>
    <code>val a = getA()</code><br>
    <code>val b = getB()</code><br><br>
    <strong>Problem?</strong><br>
    Runs sequentially, not parallel.
    <div class="fix">
        ‚úî Fix: Use <code>async</code> for parallel work.
    </div>
</div>

<div class="scenario">
    <strong>3Ô∏è‚É£ Coroutine Not Executing</strong><br><br>
    <strong>Scenario:</strong> <code>launch { delay(1000); println("Hi") }</code> inside <code>main()</code><br><br>
    <strong>Answer:</strong><br>
    No CoroutineScope; JVM exits immediately.
    <div class="fix">
        ‚úî Fix: Use <code>runBlocking</code>
    </div>
</div>

<div class="scenario">
    <strong>4Ô∏è‚É£ Child Coroutine Crash</strong><br><br>
    <strong>Scenario:</strong> One child coroutine fails ‚Üí all siblings cancel.<br><br>
    <strong>Why?</strong><br>
    Default structured concurrency behavior.
    <div class="fix">
        ‚úî Fix: Use <code>supervisorScope { }</code>
    </div>
</div>

<div class="scenario">
    <strong>5Ô∏è‚É£ Exception Not Caught</strong><br><br>
    <strong>Scenario:</strong> Exception inside <code>launch</code> not caught by try-catch.<br><br>
    <strong>Answer:</strong><br>
    <code>launch</code> is fire-and-forget.
    <div class="fix">
        ‚úî Fix: Use <code>CoroutineExceptionHandler</code> or <code>async + await</code>
    </div>
</div>

<div class="scenario">
    <strong>6Ô∏è‚É£ Memory Leak Scenario</strong><br><br>
    <strong>Scenario:</strong> Coroutine continues after Activity destroyed.<br><br>
    <strong>Answer:</strong><br>
    Used <code>GlobalScope</code>.
    <div class="fix">
        ‚úî Fix: Use <code>lifecycleScope.launch { }</code>
    </div>
</div>

<div class="scenario">
    <strong>7Ô∏è‚É£ Cancellation Not Working</strong><br><br>
    <strong>Scenario:</strong> Job cancelled but coroutine keeps running.<br><br>
    <strong>Answer:</strong><br>
    No suspension points or blocking code.
    <div class="fix">
        ‚úî Fix: Use <code>delay()</code> or check <code>isActive</code>
    </div>
</div>

<div class="scenario">
    <strong>8Ô∏è‚É£ Wrong Dispatcher Used</strong><br><br>
    <strong>Scenario:</strong> Heavy JSON parsing on <code>Dispatchers.IO</code> slows app.<br><br>
    <strong>Answer:</strong><br>
    CPU-heavy work should use <code>Dispatchers.Default</code>.
</div>

<div class="scenario">
    <strong>9Ô∏è‚É£ Flow Collection Bug</strong><br><br>
    <strong>Scenario:</strong> Flow collects multiple times after rotation.<br><br>
    <strong>Answer:</strong><br>
    Collector not lifecycle-aware.
    <div class="fix">
        ‚úî Fix: <code>repeatOnLifecycle(Lifecycle.State.STARTED)</code>
    </div>
</div>

<div class="scenario">
    <strong>üîü withContext Misuse</strong><br><br>
    <strong>Scenario:</strong> Developer uses <code>launch(Dispatchers.IO)</code> everywhere.<br><br>
    <strong>Problem?</strong><br>
    Unnecessary coroutines; breaks structured concurrency.
    <div class="fix">
        ‚úî Fix: Prefer <code>withContext(Dispatchers.IO)</code>
    </div>
</div>

<h2>üî• SUPER TRICKY BONUS</h2>

<div class="bonus">
    <strong>What happens here?</strong><br><br>
    <code>
        runBlocking {<br>
        &nbsp;&nbsp;launch { delay(1000) }<br>
        &nbsp;&nbsp;println("Done")<br>
        }
    </code><br><br>
    <strong>Answer:</strong><br>
    Prints after delay because <code>runBlocking</code> waits for all children.
</div>

<div class="one-liner">
    üéØ Interview One-Liner (MEMORIZE)<br><br>
    Coroutines follow structured concurrency: parent waits for children, cancellation propagates, and dispatcher decides thread ‚Äî not execution order.
</div>
</body>
</html>
